\startsection{Subset sum}

\textit{Runtime: O(sn)}, where s is the sum we want to find in the set of n numbers

Note: \inline{nums} is 1-indexed in these code snippets. Also, this algorithm is a special case of the 0/1 knapsack, where \inline{weight = value}.

\subsection*{Positive numbers only}

\lstinputlisting{algorithms/code/subsetsum1.java}

If you need to know which numbers were used, change lines 6-7 to:

\lstinputlisting{algorithms/code/subsetsum2.java}

And then you can retrieve which ones were used with this:

\lstinputlisting{algorithms/code/subsetsum3.java}

\subsection*{Positive numbers and negative numbers}

Invert all the negative numbers and add them to \inline{target}, then run the algorithm like normal. For example, \{-3, -2, 1, 4 =? 10\} becomes \{1, 2, 3, 4 =? 15\}.

Alternatively, you can sum all the negative numbers and sum all the positive, and run the algorithm on \inline{[negativeSum, positiveSum]} instead of \inline{[0, target]}, with an offset of \inline{negativeSum}.

\subsection*{Counting subsets}

Modifying this to count how many ways you can make \inline{target} is very easy. Change memo to an \inline{int} array, line \#3 to \inline{memo[i][0] = 1;}, and line \#8 to \inline{+=}. 

\newpage