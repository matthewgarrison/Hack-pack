\startsection{Primality and sieves}

This is a longer isPrime method, but one that is faster than the naïve version.

\lstinputlisting{general/code/primalityandsieves1.java}

\subsection*{Sieve of Eratosthenes}

\textit{Runtime: O(n log(log(n)))}

The Sieve of Erastosthenes computes primes by “marking off” multiples of all the primes before the current prime. The limit of how large a number you can check with this is based on how large an array you can make. However, you can “double” the max number by using a Sieve that only checks odd numbers. If you need a really large sieve, use a BitSet.

\lstinputlisting{general/code/primalityandsieves2.java}

You can count the number of prime factors a number has by changing lines 5-7 to:

\lstinputlisting{general/code/primalityandsieves3.java}

(A number i is prime if \inline{numPrimeFactors[i]} is 0.)

\subsection*{Totient sieve}

We can calculate $\phi(n)$ (Euler's totient function), which counts the positive integers up to a given integer $n$ that are relatively prime to $n$, using a sieve.

\lstinputlisting{general/code/primalityandsieves4.java}

\subsection*{Mod inverse sieve}

We can calculate the modular inverse of n using a sieve.

\lstinputlisting{general/code/primalityandsieves5.java}

\newpage