\startsection{Approaches and checklist}

\textbf{Checklist of stupid mistakes}

\indent BitSets allocate memory as-needed, so be careful when using \inline{.size()} for \inline{.get(fromIdx, toIdx)}. \\
\indent Don't compare two \inline{Integers} with \inline{==}. This will work for values on $[-128, 127]$ because of caching, but will fail for values outside that range. (As long as at least one variable is an \inline{int}, you can use \inline{==}.) \\
\indent FFT: The polynomial must be \textit{exactly} the one you wish to use. For example, if you are raising a polynomial to the k\textsuperscript{th} power, and you only care about indexes less than 50000, you must zero out all the indexes past 50000, every time you multiply. \\
\indent Infinity must be sufficiently large. \\
\indent Make sure you typed the sample data correctly. \\
\indent Memo table: checking the memo table at the start of the method, storing answers in the memo table before you return them, using the right indexes (ie. the current index, not \inline{n}). \\
\indent New line in \inline{printf()}. \\ 
\indent TreeSets can sometimes have a better in-practice runtime than HashSets. 

\textbf{Feasibility}

1 second: $\leq 10^8$ operations \indent\indent
5 seconds: $\leq 10^9$ operations

Approximate size-to-runtime relationships:
\begin{itemize}
    \item $n \geq 10^7$: O($n$)
    \item $n = [10^5, 10^6]$: O($n\text{ log}(n)$)
    \item $n = 10^4$: O($n^2$)
    \item $n = 10^3$: O($n^3$)
\end{itemize}

Stack size: it varies, but generally $\leq 5000$ method calls.

Memory: $\leq 5*10^7$

Bipartite matching works on sparse graphs, V $\leq$ 5000. \\
Floyd-Warshal works on sparse and dense graphs, V $\leq$ 500. \\
Dijkstraâ€™s works on sparse and dense graphs, V $\leq$ 5000. \\
Toposort works on sparse graphs, V $\leq$ 100,000.

\textbf{Techniques} \\ 
Meet in the middle \\
Can we eliminate a dimension of the memo table? \\
Can we not consider some cases of the DP? \\
Can we prune enough of the graph? \\
Pre-compute functions (eg. trig functions) outside of the loop, when possible 

\textbf{Test case generation} \\
Minimum sized case \\
Maximum sized case \\
Case that is specifically omitted from the sample \\
Case where 1 item that is true of average cases doesn't hold \\
Case with maximal answer \\
Case with minimal answer \\
Cases that test each line of code \\
Cases that check overflow of intermediate computations \\
Cases that check array out of bounds

\newpage