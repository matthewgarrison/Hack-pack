\startsection{Miscellaneous}

\subsection*{Built-in data structures}

\textbf{BitSets}

Left-shift a BitSet:

\lstinputlisting{datastructs/code/misc_bitset1.java}

To right-shift, change the size of \inline{arr} to \inline{(bs.length() - amt + 63) / 64} and lines 6-7 to:

\lstinputlisting{datastructs/code/misc_bitset2.java}

\textbf{Maps}

If you wish to use a custom class as Keys, then the class needs to implement \inline{equals()} and \inline{hashCode()}. (Eclipse can generate those for you.)

A \inline{TreeMap} sorts the Keys according to their natural ordering or a provided Comparator. Operations are mostly O($\text{log}(n)$).

A \inline{LinkedHashMap} orders the Keys according to the order in which they were inserted. "Note that insertion order is not affected if a key is re-inserted into the map. A special constructor is provided to create a linked hash map whose order of iteration is the order in which its entries were last accessed, from least-recently accessed to most-recently (access-order)." Operations are mostly O($1$) (slightly slower than \inline{HashMap}, except for iteration, which is O($n$)).

A \inline{HashMap} orders the Keys randomly. Operations are mostly O($1$) (worst case O($n$)), though iteration is O($n+capacity$).

Iterates over the values in the map, where K and V are the types of the Keys and Values in the map:

\lstinputlisting{datastructs/code/misc_builtin1.java}

\textbf{Sets}

\inline{TreeSet} and \inline{LinkedHashSet} have the same ordering as \inline{TreeMap} and \inline{LinkedHashMap}.

Classical set operations: intersection is done with \inline{Collection.retainAll}; subtraction with \\ \inline{Collection.removeAll}; union with  \inline{Collection.addAll}.

\subsection*{Disjoint Set} 

Runtime: \\
\indent Construction: O($n$) \\
\indent Union-find (with path compression): O($\alpha (n)$), where $\alpha (n)$ is the inverse Ackermann function

\lstinputlisting{datastructs/code/misc_disjointset1.java}

\subsection*{Edge (Dinic's)}

\lstinputlisting{datastructs/code/misc_edge1.java}

\subsection*{Expression (Postfix to infix)}

\lstinputlisting{datastructs/code/misc_expression1.java}

\subsection*{FastScanner}

NOTE: You should \textbf{not} have an extra \inline{nextLine()} call when transitioning from \inline{nextInt()} to \inline{nextLine()}. (This is different from a Scanner, where you do.)

\lstinputlisting{datastructs/code/misc_fastscanner1.java}

\subsection*{Intervals}

Runtime: O($\text{log}(n)$)

\lstinputlisting{datastructs/code/misc_intervals1.java}

If you want consecutive intervals with the same value to combine, change \inline{paint()} to:

\lstinputlisting{datastructs/code/misc_intervals2.java}

\subsection*{MinQueue}

Runtime: O($1$) for all operations (amortized)

Convert to a \inline{MinStack} by changing all the \inline{Last} operations to \inline{First}s.

\lstinputlisting{datastructs/code/misc_minqueue1.java}


\newpage